import whisper
import sounddevice as sd
import webrtcvad
import numpy as np
import soundfile as sf
import queue
import collections
from threading import Thread
import tkinter as tk
import os
import re
from datetime import datetime, timedelta, date, time
from typing import Optional, Union, Tuple

# ëª¨ë¸ ë¡œë“œ (medium ì´ìƒ ì¶”ì²œ)
model = whisper.load_model("medium")

SAMPLE_RATE = 16000  # WhisperëŠ” 16kHz í•„ìš”
CHUNK_SIZE = 320  # 20ms (16000Hz * 0.02s = 320 samples)
VAD_WINDOW = 50  # ìµœê·¼ 50ê°œì˜ VAD ê²°ê³¼ í™•ì¸
SILENCE_THRESHOLD = 10  # ì¹¨ë¬µ ê°ì§€ ì„ê³„ê°’ (ì ˆë°˜ ì´ìƒì´ ë¬´ìŒì´ë©´ ì¢…ë£Œ)

vad = webrtcvad.Vad(1)  # 0~3 (ë†’ì„ìˆ˜ë¡ ì¹¨ë¬µ ê°ì§€ ì •í™•ë„ â†‘)

# ì˜¤ë””ì˜¤ í (ë¹„ë™ê¸° ì²˜ë¦¬)
audio_queue = queue.Queue()
vad_history = collections.deque(maxlen=VAD_WINDOW)
is_recording = False


class DateParser:
    def __init__(self):
        # í•œê¸€ ìˆ«ì ë§¤í•‘
        self.korean_numbers = {
            'ì¼': 1, 'ì´': 2, 'ì‚¼': 3, 'ì‚¬': 4, 'ì˜¤': 5,
            'ìœ¡': 6, 'ì¹ ': 7, 'íŒ”': 8, 'êµ¬': 9, 'ì‹­': 10,
            'í•˜ë‚˜': 1, 'ë‘˜': 2, 'ì…‹': 3, 'ë„·': 4, 'ë‹¤ì„¯': 5,
            'ì—¬ì„¯': 6, 'ì¼ê³±': 7, 'ì—¬ëŸ': 8, 'ì•„í™‰': 9, 'ì—´': 10
        }

        # ì‹œê°„ ë‹¨ìœ„ ë§¤í•‘
        self.time_units = {
            'ì´ˆ': 'seconds',
            'ë¶„': 'minutes',
            'ì‹œê°„': 'hours',
            'ì¼': 'days',
            'ì£¼': 'weeks',
            'ê°œì›”': 'months',
            'ë…„': 'years'
        }

    def _convert_korean_to_number(self, text: str) -> int:
        """í•œê¸€ ìˆ«ìë¥¼ ì•„ë¼ë¹„ì•„ ìˆ«ìë¡œ ë³€í™˜"""
        if text.isdigit():
            return int(text)

        for kor, num in self.korean_numbers.items():
            if text == kor:
                return num
        return 0

    def parse_absolute_date(self, text: str) -> Optional[datetime]:
        """ì ˆëŒ€ì ì¸ ë‚ ì§œ í‘œí˜„ì„ íŒŒì‹±í•˜ì—¬ datetime ê°ì²´ë¡œ ë°˜í™˜"""
        # í˜„ì¬ ì—°ë„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
        current_year = datetime.now().year

        # ì›”, ì¼, ì‹œê°„ íŒ¨í„´ ë§¤ì¹­
        pattern = r'(\d+)ì›”\s*(\d+)ì¼\s*(?:ì˜¤ì „|ì˜¤í›„)?\s*(\d+)ì‹œ'
        match = re.search(pattern, text)

        if not match:
            return None

        month = int(match.group(1))
        day = int(match.group(2))
        hour = int(match.group(3))

        # ì˜¤í›„ì¸ ê²½ìš° 12ë¥¼ ë”í•¨
        if 'ì˜¤í›„' in text and hour != 12:
            hour += 12

        try:
            return datetime(current_year, month, day, hour)
        except ValueError:
            return None

    def parse_relative_date(self, text: str, base_date: Optional[datetime] = None) -> Optional[datetime]:
        """
        ìƒëŒ€ì ì¸ ë‚ ì§œ í‘œí˜„ì„ íŒŒì‹±í•˜ì—¬ datetime ê°ì²´ë¡œ ë°˜í™˜
        ì˜ˆ: "3ì¼ í›„", "ì¼ì£¼ì¼ í›„", "2ê°œì›” í›„" ë“±
        """
        if base_date is None:
            base_date = datetime.now()

        # íŒ¨í„´ ë§¤ì¹­
        pattern = r'(\d+|[ê°€-í£]+)\s*([ê°€-í£]+)\s*(í›„|ë’¤)'
        match = re.search(pattern, text)

        if not match:
            return None

        amount = self._convert_korean_to_number(match.group(1))
        unit = match.group(2)

        if unit not in self.time_units:
            return None

        # ì‹œê°„ ë‹¨ìœ„ì— ë”°ë¼ ë‚ ì§œ ê³„ì‚°
        if self.time_units[unit] == 'months':
            # ê°œì›” ë‹¨ìœ„ëŠ” íŠ¹ë³„ ì²˜ë¦¬
            new_month = base_date.month + amount
            new_year = base_date.year + (new_month - 1) // 12
            new_month = ((new_month - 1) % 12) + 1
            return base_date.replace(year=new_year, month=new_month)
        elif self.time_units[unit] == 'years':
            return base_date.replace(year=base_date.year + amount)
        else:
            # timedeltaë¡œ ì²˜ë¦¬ ê°€ëŠ¥í•œ ë‹¨ìœ„ë“¤
            kwargs = {self.time_units[unit]: amount}
            return base_date + timedelta(**kwargs)

    def parse(self, text: str) -> Tuple[Optional[datetime], Optional[datetime]]:
        """
        ë‚ ì§œ ë¬¸ìì—´ì„ íŒŒì‹±í•˜ì—¬ (ì ˆëŒ€ ë‚ ì§œ, ìƒëŒ€ ë‚ ì§œ) íŠœí”Œë¡œ ë°˜í™˜
        """
        absolute_date = None
        relative_date = None

        # ì ˆëŒ€ ë‚ ì§œ íŒŒì‹±
        absolute_date = self.parse_absolute_date(text)

        # ìƒëŒ€ ë‚ ì§œ íŒŒì‹± (ì ˆëŒ€ ë‚ ì§œê°€ ìˆëŠ” ê²½ìš° ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°)
        if 'í›„' in text or 'ë’¤' in text:
            base_date = absolute_date if absolute_date else datetime.now()
            relative_date = self.parse_relative_date(text, base_date)

        return absolute_date, relative_date


# ë‚ ì§œ í•´ì„ ìœ í‹¸
# ë‚ ì§œ í•´ì„ ìœ í‹¸ - ìˆ˜ì •ë¨
def resolve_relative_dates(text, base_date=None):
    if base_date is None:
        base_date = date.today()

    replacements = {
        "ì˜¤ëŠ˜": base_date,
        "ë‚´ì¼": base_date + timedelta(days=1),
        "ë‹¤ìŒ ë‚ ": base_date + timedelta(days=1),
        "ëª¨ë ˆ": base_date + timedelta(days=2),
        "ê°™ì€ ë‚ ": base_date,
    }

    for key, value in replacements.items():
        text = text.replace(key, value.strftime("%Y-%m-%d"))
    return text


def extract_schedule(text):
    from datetime import time
    schedules = []
    parser = DateParser()
    current_date = date.today()

    # ê³ ê¸‰ íŒ¨í„´ìœ¼ë¡œ ìƒëŒ€/ì ˆëŒ€/ìì—°ì–´ ë‚ ì§œ ëª¨ë‘ í¬í•¨
    pattern = r'(?:(\d{1,2}ì›”\s*\d{1,2}ì¼|\d{4}-\d{2}-\d{2}|[ê°€-í£\d]+\s*(ì¼|ì£¼|ê°œì›”|ë…„)?\s*(í›„|ë’¤)|ì˜¤ëŠ˜|ë‚´ì¼|ëª¨ë ˆ|ê°™ì€ ë‚ )?)?\s*(ì˜¤ì „|ì˜¤í›„)?\s*(\d{1,2})ì‹œ.*?(íšŒì˜|ì ì‹¬|ì‹ì‚¬|ë³‘ì›|ì•½ì†|ë¯¸íŒ…|ì „í™”|ë§Œë‚˜.*?)'
    matches = re.findall(pattern, text)

    for m in matches:
        raw_date_expr, _, _, ampm, hour, task = m

        # 1. ë‚ ì§œ ì²˜ë¦¬
        if raw_date_expr:
            absolute_date, relative_date = parser.parse(raw_date_expr)
            if absolute_date:
                current_date = absolute_date.date()
            elif relative_date:
                current_date = relative_date.date()
            else:
                try:
                    if 'ì›”' in raw_date_expr:
                        raw_date = raw_date_expr.replace("ì›”", "-").replace("ì¼", "").replace(" ", "")
                        current_date = datetime.strptime(f"2025-{raw_date}", "%Y-%m-%d").date()
                    elif '-' in raw_date_expr:
                        current_date = datetime.strptime(raw_date_expr, "%Y-%m-%d").date()
                    elif raw_date_expr in ['ì˜¤ëŠ˜', 'ë‚´ì¼', 'ëª¨ë ˆ', 'ê°™ì€ ë‚ ']:
                        current_date = resolve_relative_dates(raw_date_expr)
                except:
                    current_date = date.today()

        # ğŸ”¥ 2. task ë‚´ë¶€ì— ë˜ ë‹¤ë¥¸ ìƒëŒ€ í‘œí˜„ì´ ìˆìœ¼ë©´ â†’ current_date ì¬ì¡°ì •
        # ìƒëŒ€ ë‚ ì§œ íŒ¨í„´ (ì˜ˆ: "ì¼ì£¼ì¼ ë’¤", "3ì¼ í›„" ë“±)
        relative_pattern = r'([ê°€-í£\d]+)\s*(ì¼|ì£¼|ê°œì›”|ë…„)?\s*(í›„|ë’¤)'
        relative_match = re.search(relative_pattern, task)

        if relative_match:
            amount_text = relative_match.group(1)
            unit = relative_match.group(2) if relative_match.group(2) else 'ì¼'

            # í•œê¸€ ìˆ«ì ë³€í™˜
            amount = parser._convert_korean_to_number(amount_text)
            if amount == 0 and amount_text.isdigit():
                amount = int(amount_text)

            # ê¸°ì¤€ ë‚ ì§œ ì„¤ì • (ì´ì „ ì¼ì •ì˜ ë‚ ì§œ ì‚¬ìš©)
            base_date = datetime.combine(current_date, time(0, 0))

            # ìƒëŒ€ ë‚ ì§œ ê³„ì‚°
            if unit == 'ê°œì›”':
                new_month = base_date.month + amount
                new_year = base_date.year + (new_month - 1) // 12
                new_month = ((new_month - 1) % 12) + 1
                current_date = base_date.replace(year=new_year, month=new_month).date()
            elif unit == 'ë…„':
                current_date = base_date.replace(year=base_date.year + amount).date()
            else:
                # timedeltaë¡œ ì²˜ë¦¬ ê°€ëŠ¥í•œ ë‹¨ìœ„ë“¤
                kwargs = {parser.time_units[unit]: amount}
                current_date = (base_date + timedelta(**kwargs)).date()

            # taskì—ì„œ ìƒëŒ€ ë‚ ì§œ í‘œí˜„ ì œê±°
            task = re.sub(relative_pattern, '', task).strip()

        # 3. ì‹œê°„ ì²˜ë¦¬
        hour = int(hour)
        if ampm == "ì˜¤í›„" and hour < 12:
            hour += 12
        time_obj = time(hour=hour)

        schedules.append({
            "date": current_date,
            "time": time_obj,
            "task": task.strip()
        })

    return schedules


def start_recording():
    global is_recording
    is_recording = True
    status_label.config(text="ğŸ¤ ìŒì„± ì¸ì‹ ì¤‘...")

    def record_audio():
        global is_recording
        frames = []
        vad_history.clear()
        warmup_counter = 50
        post_warmup_frames = 50

        def callback(indata, frames, time, status):
            if status:
                print(status)
            try:
                audio_queue.put_nowait(indata.copy())
            except queue.Full:
                pass

        with sd.InputStream(callback=callback, samplerate=SAMPLE_RATE, channels=1, blocksize=CHUNK_SIZE, device=1):
            while is_recording:
                try:
                    # íì—ì„œ ì˜¤ë””ì˜¤ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                    data = audio_queue.get_nowait()
                    frames.append(data)

                    # VADë¡œ ìŒì„± ê°ì§€
                    pcm_audio = (data * 32768).astype(np.int16)

                    # âœ… ìµœì†Œ ë…¹ìŒ ë³´ì¥ (ì²˜ìŒ 50ê°œ í”„ë ˆì„ì€ ë¬´ì¡°ê±´ ì €ì¥)
                    if warmup_counter > 0:
                        warmup_counter -= 1
                        continue  # 1ì´ˆ ë™ì•ˆ ë¬´ì¡°ê±´ ë…¹ìŒ ìœ ì§€
                    try:
                        is_speech = vad.is_speech(pcm_audio.tobytes(), SAMPLE_RATE)
                    except webrtcvad.Error:
                        print(f"âš ï¸ VAD Error: {e}")
                        continue
                    vad_history.append(1 if is_speech else 0)

                    if post_warmup_frames > 0:
                        post_warmup_frames -= 1
                        continue

                    # ìµœê·¼ VAD ê°’ ì¤‘ ì ˆë°˜ ì´ìƒì´ ì¹¨ë¬µì´ë©´ ì¢…ë£Œ
                    if sum(vad_history) < SILENCE_THRESHOLD:
                        print("ìŒì„± ì¢…ë£Œ ê°ì§€, ë³€í™˜ ì‹œì‘...")
                        break
                except queue.Empty:
                    pass  # íê°€ ë¹„ì–´ìˆìœ¼ë©´ ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰

            # ğŸ¤ ìµœì†Œ ë…¹ìŒ ê¸¸ì´ ì²´í¬ (1ì´ˆ ë¯¸ë§Œì´ë©´ ë¬´ì‹œ)
            if len(frames) < 50:
                print("âš ï¸ ë…¹ìŒëœ ë°ì´í„°ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
                status_label.config(text="âš ï¸ ì§§ì€ ë…¹ìŒ. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
                is_recording = False
                return
            # 1ì´ˆ ëŒ€ê¸° í›„ ë³€í™˜ ì‹œì‘
            root.after(1000, lambda: transcribe_audio(frames))

    Thread(target=record_audio, daemon=True).start()


def transcribe_audio(frames):
    global is_recording
    is_recording = False

    audio_data = np.concatenate(frames, axis=0).flatten()
    wav_filename = "recorded_audio.wav"
    sf.write(wav_filename, audio_data, SAMPLE_RATE)
    print(f"ğŸ“ Audio Data Shape: {audio_data.shape}")
    print(f"ğŸ”Š Min: {audio_data.min()}, Max: {audio_data.max()}")

    if os.path.exists(wav_filename):
        print(f"âœ… íŒŒì¼ ì €ì¥ ì™„ë£Œ: {wav_filename}, í¬ê¸°: {os.path.getsize(wav_filename)} bytes")
    else:
        print("âš ï¸ íŒŒì¼ ì €ì¥ ì‹¤íŒ¨!")

    result = model.transcribe(wav_filename, language="ko", fp16=False)
    recognized_text = result["text"]

    schedules = extract_schedule(recognized_text)

    # ê²°ê³¼ ì¶œë ¥
    status_label.config(text="âœ… ì¸ì‹ ì™„ë£Œ!")
    text_output.delete("1.0", tk.END)
    text_output.insert(tk.END, recognized_text + "\n\n")

    if schedules:
        text_output.insert(tk.END, "ğŸ“… ë¶„ì„ëœ ì¼ì •:\n")
        for s in schedules:
            text_output.insert(tk.END, f"- {s['date']} {s['time']} : {s['task']}\n")

    print("Recognized Text:", recognized_text)

# GUI ì„¤ì •
root = tk.Tk()
root.title("ìŒì„± ì¸ì‹ ì¼ì • ì¶”ì¶œê¸°")

start_button = tk.Button(root, text="ğŸ™ï¸ ì‹œì‘", command=start_recording, font=("Arial", 14))
start_button.pack(pady=10)

status_label = tk.Label(root, text="ë²„íŠ¼ì„ ëˆŒëŸ¬ ìŒì„± ì¸ì‹ì„ ì‹œì‘í•˜ì„¸ìš”", font=("Arial", 12))
status_label.pack(pady=5)

text_output = tk.Text(root, height=10, width=60, font=("Arial", 12))
text_output.pack(pady=10)

root.mainloop()
